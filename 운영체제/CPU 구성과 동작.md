## 2-1. CPU 구성과 동작

### CPU 기본 구성

- **산술논리 연산장치(ALU)**
    - 산술 연산, 논리 연산 수행.
- **제어장치**
    - 작업 지시
- **레지스터**
    - 작업에 필요한 데이터를 cpu 내부에 보관

### CPU 명령어 처리 과정

- 프로그래밍 언어 → 변수 선언 → 메모리내 공간 만듦.

e.g. 두수의 덧셈 프로그램-유사코드

```
int D2 = 2; // 메모리 100번지가 D2라 가정
int D3 = 2; // 메모리 120번지가 D3라 가정

int sum; // 메모리 160번지가 sum이라 가정

sum = D2 + D3;
```

두수의 덧셈 프로그램-에섬블리어 유사코드

```
LOAD mem(100), register 2 // 1. 메모리 100번지 내용을 R2로 이동
LOAD mem(120), register 3 // 2. 메모리 120번지 내용을 R3로 이동
ADD register 5, register 2, register 3 // 3. R2+ R3 -> R5에 임시저장
MOVE register 5, mem(160) // 4. R5 결과를 160번지에 저장.
```

1. 100번지 값을 CPU로 가져와라. 100번지 → D2의미. D2에 있는 2가 CPU의 레지스터 2로 옮겨짐. 레지스터 2는 덧셈전 데이터를 임시보관
2. 메모리 120번지(D3)의 3이 덧셈 연산 전 레지스터 3에 잠시 보관
3. 레지스터2(D2)의 값과 레지스터3(D3)의 값 더해라. 더한 값은 레지스터5에 임시 저장. 덧셈 숫자 5는 sum(160번지)에 저장
4. 레지스터5에 임시 저장된 5를 메모리 160번지(sum)에 옮김.

### 레지스터 종류

- CPU → 필요한 데이터를 메모리에서 가져와 레지스터에 저장
- 산술논리 연산장치 → 연산 → 레지스터에 저장 → 메모리 옮김
- 이때 사용되는 레지스터
    - **데이터 레지스터**
        - 메모리에서 가져온 데이터 임시 보관
        - 대부분의 CPU 레지스터
    - **주소 레지스터**
        - 데이터, 명령어가 저장된 메모리 주소
- 그외 특수 레지스터
    - **프로그램 카운터(PC)**
        - CPU는 다음에 어떤 명령어 처리해야할지 알아야 함.
        - 다음에 실행될 명령어의 주소를 기억 → 제어장치에 알려줌.
        - == 명령어 포인터
    - 명령어 레지스터(IR)
        - 실행중인 명령어 저장
    - **메모리 주소 레지스터(MAR)**
        - 데이터를 메모리에서 가져오거나 보낼때 주소를 지정하는데 사용
    - 메모리 버퍼 레지스터(MBR)
        - 메모리에서 가져오거나 옮겨갈 데이터를 임시로 저장.
        - 항상 메모리 주소 레지스터와 함께 동작

### 버스의 종류

- CPU와 메모리, 주변장치 간 데이터 주고받을 때 시스템 버스 사용
- 제어 버스
    - **제어장치와** 연결된 버스
    - CPU가 메모리와 주변장치에 제어 신호 보낼 때 사용
- 주소 버스
    - **메모리 주소 레지스터**와 연결된 버스
    - 데이터 읽거나 쓸 때 메모리나 주변장치에 위치 정보를 보낼때 사용
- 데이터 버스
    - **메모리 버퍼 레지스터**와 연결된 버스
    - 데이터 이동 양방향.
    

### CPU 비트의 의미

- 32bit CPU, 64bit CPU → CPU가 한번에 처리할 수 있는 데이터 최대 크기(데이터버스를 통해 가져오는 데이터 크기)
- 버스 대역폭(bandwidth)→ 한번에 전달할 수 있는 데이터 최대 크기
    - CPU가 한번에 처리할 수 있는 최대 크기와 같음.
- 버스 대역폭, 레지스터 크기, 메모리에 한번에 저장할 수 있는 데이터 크기 항상 같음.
- CPU가 한번에 처리할 수 있는 데이터 최대 크기 == 워드.

## 2. 메모리의 종류와 부팅

### 메모리 종류

- RAM
    - 읽고 쓰기 가능
    - 전력 끊기면 데이터 사라지는
        - 휘발성: DRAM, SRAM, SDRAM
        - 비휘발성: 플래시 메모리, FRAM, PRAM
        
- ROM
    - 읽기만 가능

### 메모리 보호

- 시분할 기법을 사용하는 현대 os → 여러 프로그램 동시 실행 → 메모리 보호 매우 중요.
- 메모리 시작 주소를 **경계 레지스터**에 저장.
- 현재 진행 중인 작업이 차지하고 있는 메모리 크기(마지막 주소까지의 차이)를 **한계 레지스터**에 저장.

### 부팅

- 컴퓨터 on → os를 메모리에 올리는 과정
- 사용자→ 전원 on → ROM(비휘발성)에 저장된 바이오스(Basic Input/Output System) 실행.

## 3. 컴퓨터 성능 향상 기술

### 1. 버퍼

- 두 장치 사이 속도 차이 완화
- 일정량의 데이터를 모아 옮김 → 속도 차이 완화

### 스풀

- CPU와 입출력장치 독립적 동작하도록 소프트웨어적인 버퍼.

### 캐시

- 메모리-CPU간 속도 차이(BSB-FSB 속도 차이)를 완화하기 위해 메모리 데이터를 미리 가져와 저장해두는 임시 장소
- 필요한 데이터를 모아 한꺼번에 전달하는 `버퍼` 의 일종
- CPU가 앞으로 사용될 것으로 예상되는 데이터를 미리 가져다 놓음.
- CPU→ 메모리 접근시 캐시 먼저 방문 → 원하는 데이터 있는 지 확인.

**캐시 구조**

- 캐시 히트: 캐시에서 원하는 데이터를 찾음. 데이터 바로 사용
- 캐시 미스: 캐시에 원하는 데이터 없으면 메모리 가서 찾음
- 캐시 적중률: 캐시 히트되는 비율. 일반적인 캐시 적중률 약 90%.

**버퍼**

- 즉시 쓰기
    - 캐시에 있는 데이터 변경 → 이를 즉시 메모리 반영
    - 빈번한 데이터 전송 → 성능 느려짐
- 지연 쓰기
    - 즉시 반영 x →  변경된 내용을 모아 주기적으로 반영
    - 카피백(copy back)이라고도 함
    - 시스템 성능 향상
    - 불일치 발생 가능

**L1캐시와 L2 캐시**

- 캐시는 명령어, 데이터 구분없이 모든자료를 가져오는 **일반 캐시**
- 명령어와 데이터를 구분해 가져오는 **특수 캐시**로 구분
    - 일반캐시: 메모리와 연결→L2(Leve2)캐시
    - 특수캐시: CPU 레지스터에 직접 연결 → L1(Level1)캐시

### 2. 저장장치의 계층 구조

- 느린 하드디스크 대신 ssd와 같은 빠른 플래시 메모리 저장장치로 사용
- 메모리를 하드디스크 만큼 확장
- 캐시를 크게 늘려 적중률 향상.

### 인터럽트

**폴링(polling)방식**

- **CPU**가 **직접** 입출력장치에서 데이터 가져오거나 내보내는 방식
- 입출력장치 상태 주기적 검사 → 일정 조건을 만족할 때 데이터 처리
- CPU가 명령어 해석, 실행이라는 본래 역할 외 모든 입출력 관여 → **작업 효율 하락**

**인터럽트(interrupt) 방식**

- **입출력관리자**가 **대신** 입출력 해주는 방식
- CPU 작업, 저장장치 데이터 이동, 독립적으로 운영 → **시스템 효율 높임**
- 데이터 입출력 → cpu 다른 작업 가능

### 3. 인터럽트

- 인터럽트 방식 동작 과정
    1. CPU가 입출력 관리자에게 명령 내림
    2. 입출력 관리자→ 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮김.
    3. 데이터 전송 완료 → 입출력 관리자는 CPU에 완료 신호 보냄
- 입출력 관리자가 CPU에 보내는 신호 → **인터럽트**
- CPU는 입출력 관리자 → 작업 지시 내림
    - 다른 일을 하다가..
    - 완료 신호! 를 받으면 하던 일 중단 후 옮겨진 데이터 처리.
    - 이처럼 하던 작업을 중단하고 처리해야 하는 신호 라는 의미 ⇒ 인터럽트
- 즉, 인터럽트 ⇒ 입출력 관리자가 CPU에 보내는 **완료 신호**
- 인터럽트 번호
    - 많은 주변장치 중 어떤것의 작업이 끝났는지 CPU에 알려주기 위해 사용하는 번호
    - 윈도우 운영체제에서는 IRQ라 부름
- 인터럽트 벡터
    - 여러개의 입출력 장치를 한꺼번에 처리하기 위해 여러 개의 인터럽트를 하나의 배열로 만든것

### 4. 직접 메모리 접근

- 과거) 운영체제 → 폴링방식 사용
    - CPU가 직접 메모리나 주변장치에 접근하는 권한 가짐
    - 그러나 인터럽트 방식을 사용 → 입출력관리자가 데이터 입출력 맡게됨.
    - 입출력이 필요할 때→ CPU는 입출력관리자에게 입출력 요청 → 하던 일 계속..
    - 명령받은 입출력 관리자 → CPU가 요청한 데이터를 메모리에 가져다 두어야 함
        - 이때 문제 발생🚨
        - 메모리는 **CPU만 접근 권한을 가진 작업 공간** → 입출력 관리자는 접근 불가
        - 따라서 입출력 관리자→ 메모리에 접근할 수 있는 권한 필요.
        - 이를 **직접 메모리 접근**이라고 함
            - 데이터 전송을 지시받은 **입출력 관리자** → **직접 메모리 접근 권한** 있어야 CPU 관여 없이 작업 완료 가능
        

### 5. 메모리 맵 입출력

- 직접 메모리 접근 → 인터럽트 방식의 시스템 구성시 필수요소 → but 메모리 복잡해짐
- 메모리 : CPU가 사용하는 데이터, 입출력 장치가 사용하는 데이터 **섞여있음**
- 직접 메모리 접근을 통해 들어온 데이터 → 나눠 저장.
- CPU가 사용하는 공간, 직접 메모리 접근을 통해 들어오고 나가는 데이터를 위한 공간을 분리
- 이렇게 메모리의 일정 공간을 입출력에 할당 → 메모리 맵 입출력(MMIO; Memory Map Input/Output)

### 6. 사이클 훔치기

- 메모리 : CPU가 관할하는 중요한 장치
- but 직접 메모리 접근 → 입출력도 메모리 사용 가능
- 그런데 CPU, 직접 메모리 접근 → 동시에 메모리 접근 시?
    - 보통은 CPU가 메모리 사용 권한 양보
    - CPU 작업 속도가 입출력장치 속도보다 느리기 때문
    - CPU 입장에서는 직접 메모리 접근이 사이클(순서)를 훔쳐간 것.

# 4. 멀티 프로세싱

## 1. 멀티코어 시스템

### 멀티 프로세서 시스템

- 컴퓨터의 성능을 높이기 위해 **프로세서를 여러 개 설치**하여 사용하는 시스템(=cpu 여러 대 있는 시스템)
- 프로세서마다 레지스터와 캐시를 가지며, 모든 프로세서가 시스템 버스를 통해 메인 메모리를 공유
- 장점: **많은 작업을 동시에 실행시킬 수 있음**

### 멀티코어 시스템

- 기존 시스템을 유지한 채 **멀티 프로세싱을 할 수 있게 하는 시스템**(=하나의 cpu에 여러 코어가 붙은 것)
- 하나의 칩(chip)에 CPU의 핵심이 되는 코어(core;각 명령어를 수행하기 위한 ALU(Arithmetic Logic Unit), CU(control unit), 레지스터를 가짐)를 여러 개 만들어 여러 작업을 동시에 처리
- 듀얼코어(dual core)는 CPU의 주요 기능을 담당하는 코어가 2개, 쿼드코어(quad core)는 4개

## 2. CPU 멀티 스레드

### 명령어 병렬 처리(instruction parallel processing)

- 하나의 코어에서 여러 개의 명령어를 동시에 처리하는 것

### CPU 멀티스레드(multithread)

- 여러 개의 스레드를 동시에 처리하는 방법
- 스레드(thread)
    - CPU가 처리할 수 있는 작업의 단위

**현대의 CPU**

- 하나의 칩에 **멀티코어**와 **명령어 병렬 처리 기능**을 한꺼번에 구현

### CPU 관련 통용 법칙

1. 무어의 법칙
    1. CPU속도가 24개월마다 2배씩 빨라진다는 법칙
2. 암달의 법칙
    1. 주변장치의 향상 없이 CPU 속도를 2GHz → 4GHz로 늘려도 컴퓨터 성능이 2배 빨라지지 않는다는 법칙
    2. 심지어 CPU 속도를 올려도 메모리를 비롯한 주변장치가 CPU의 발전속도를 따라가지 못해 컴퓨터의 전반적인 성능은 저하.